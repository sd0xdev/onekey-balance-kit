---
description: 區塊鏈服務模組
globs:
alwaysApply: false
---
# 區塊鏈服務模組

本專案實現了一個模組化的區塊鏈服務架構，通過統一介面支援多種區塊鏈。`src/chains` 目錄包含核心業務邏輯和區塊鏈操作模組。

## 架構概述

系統使用混合架構設計，結合了工廠模式、裝飾器自動註冊和模組化原則：

1. **統一介面**：所有鏈服務實現 [ChainService](mdc:src/chains/interfaces/chain-service.interface.ts) 介面
2. **餘額功能擴展**：支援餘額查詢的鏈服務額外實現 [BalanceQueryable](mdc:src/chains/interfaces/balance-queryable.interface.ts) 介面
3. **抽象基類**：[AbstractChainService](mdc:src/chains/services/abstract-chain.service.ts) 提供通用實現
4. **工廠模式**：[ChainServiceFactory](mdc:src/chains/services/chain-service.factory.ts) 管理服務實例
5. **裝飾器註冊**：使用 [@Chain](mdc:src/chains/decorators/chain.decorator.ts) 裝飾器自動發現和註冊服務
6. **錯誤處理**：使用 [ErrorCode](mdc:src/common/constants/error-codes.ts) 和自定義異常提供統一錯誤處理

## 目錄結構

```
src/chains/
├── interfaces/                    # 介面定義
│   ├── chain-service.interface.ts # 鏈服務介面
│   └── balanceable-chain.interface.ts # 餘額服務介面
├── decorators/                    # 裝飾器定義
│   └── chain.decorator.ts         # 鏈服務裝飾器
├── services/                      # 服務實現
│   ├── abstract-chain.service.ts  # 抽象鏈服務基類
│   ├── chain-service.factory.ts   # 鏈服務工廠
│   ├── discovery.service.ts       # 裝飾器發現服務
│   ├── ethereum/                  # 以太坊服務
│   │   └── ethereum.service.ts
│   └── solana/                    # Solana 服務
│       └── solana.service.ts
├── controllers/                   # 控制器
│   └── chains.controller.ts       # 鏈服務 API 控制器
├── modules/                       # 模組定義
│   ├── chains.module.ts           # 主鏈服務模組
│   ├── ethereum/                  # 以太坊模組
│   │   └── ethereum.module.ts
│   └── solana/                    # Solana 模組
│       └── solana.module.ts
├── constants/                     # 常量定義
│   └── index.ts                   # 鏈相關常量
└── index.ts                       # 入口檔案
```

## 支援的區塊鏈

目前支援的區塊鏈包括：

- **以太坊** (ETH)：完整支援地址驗證、交易查詢、餘額查詢
- **Solana** (SOL)：完整支援地址驗證、交易查詢、餘額查詢

## 使用方法

1. **注入工廠服務**：
   ```typescript
   constructor(private readonly chainServiceFactory: ChainServiceFactory) {}
   ```

2. **獲取特定鏈服務**：
   ```typescript
   // 使用鏈名稱
   const ethService = this.chainServiceFactory.getChainService(ChainName.ETHEREUM);

   // 也可使用代幣符號（不區分大小寫）
   const solService = this.chainServiceFactory.getChainService('sol');
   ```

3. **使用服務方法**：
   ```typescript
   // 基本功能
   const isValid = ethService.isValidAddress('0x...');
   const txHashes = await solService.getAddressTransactionHashes('sol_address');

   // 餘額查詢功能 (需要先確保服務實現了 BalanceQueryable 介面)
   if (isBalanceQueryable(ethService)) {
     const balances = await ethService.getBalances('0x...');
   }
   ```

4. **類型檢查**：
   ```typescript
   import { isBalanceQueryable } from '../interfaces/balance-queryable.interface';

   // 使用類型守衛函數檢查服務是否支援餘額查詢
   if (isBalanceQueryable(service)) {
     // 安全地使用 getBalances 方法
   }
   ```

## 餘額查詢 API

`BalanceQueryable` 介面提供了獲取區塊鏈地址餘額的能力：

```typescript
export interface BalanceQueryable {
  /**
   * 獲取特定地址的餘額資訊
   * @param address 區塊鏈地址
   * @param useTestnet 是否使用測試網絡，默認為 false
   * @returns 包含餘額信息的對象
   */
  getBalances(address: string, useTestnet?: boolean): Promise<BalanceResponse>;
}
```

所有餘額查詢返回統一的 `BalanceResponse` 格式，包含原生代幣、代幣和 NFT 資訊。

## 錯誤處理

系統使用統一的錯誤處理機制：

1. **錯誤代碼**：使用 `ErrorCode` 枚舉定義不同類型的錯誤
2. **自定義異常**：使用 `BlockchainException`, `BalanceException` 等自定義異常類
3. **統一格式**：HTTP 響應以統一格式返回錯誤信息

例如，處理無效地址：

```typescript
if (!chainService.isValidAddress(address)) {
  throw new BlockchainException(
    ErrorCode.BLOCKCHAIN_INVALID_ADDRESS,
    `Invalid ${chain} address: ${address}`,
  );
}
```

## API 端點

鏈服務模組提供了以下 API 端點：

- `GET /chains`: 獲取所有支持的鏈類型
- `GET /chains/:chain/validate/:address`: 驗證地址是否有效
- `GET /chains/:chain/transactions/:address`: 獲取地址的交易歷史
- `GET /balances/:chain/:address`: 獲取地址的餘額資訊

## 擴展新區塊鏈

添加新的區塊鏈支援需要：

1. 更新 [constants/index.ts](mdc:src/chains/constants/index.ts) 中的 `ChainName` 枚舉
2. 創建繼承 `AbstractChainService` 的服務類並使用 `@Chain()` 裝飾器
3. 可選：實現 `BalanceQueryable` 介面提供餘額查詢功能
4. 在主模組中導入新的鏈特定模組

### 添加新的鏈服務示例

```typescript
import { Injectable } from '@nestjs/common';
import { AbstractChainService, Chain, ChainName } from '../chains';
import { BalanceQueryable, BalanceResponse } from '../interfaces/balance-queryable.interface';

@Injectable()
@Chain(ChainName.YOUR_CHAIN)
export class YourChainService extends AbstractChainService implements BalanceQueryable {
  getChainName(): string {
    return ChainName.YOUR_CHAIN;
  }

  getChainSymbol(): string {
    return 'YCN';
  }

  isValidAddress(address: string): boolean {
    // 實現驗證邏輯
    return true;
  }

  async getAddressTransactionHashes(address: string): Promise<string[]> {
    // 實現獲取交易哈希的邏輯
    return ['hash1', 'hash2'];
  }

  async getTransactionDetails(hash: string): Promise<any> {
    // 實現獲取交易詳情的邏輯
    return { hash, details: 'some details' };
  }

  async getBalances(address: string, useTestnet = false): Promise<BalanceResponse> {
    // 實現餘額查詢邏輯
    return {
      nativeBalance: {
        symbol: this.getChainSymbol(),
        decimals: 18,
        balance: '1000000000000000000'
      },
      tokens: [],
      nfts: [],
      updatedAt: Math.floor(Date.now() / 1000)
    };
  }
}
```

詳細實作請參考 [README.md](mdc:src/chains/README.md) 中的擴展指南。
