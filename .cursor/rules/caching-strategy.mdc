---
description: 快取策略
globs:
alwaysApply: false
---
# 多層快取策略

OneKeyBalanceKit 實現了三層快取策略，用於優化區塊鏈資產餘額查詢性能：

## 快取層次

1. Cloudflare Edge 快取（最外層）
2. Redis 快取（中間層）
3. MongoDB 持久化存儲（最內層）

## 實現細節

[CacheService](mdc:src/core/cache/cache.service.ts) 是主要的快取服務實現，該服務：

- 使用 NestJS 的 `@nestjs/cache-manager` 集成
- 支持可降級的快取策略（Redis 失敗時降級為內存快取）
- 提供通用的快取接口：get、set、delete、reset

## Webhook 驅動的快取失效

系統使用 Webhook 事件通知來主動使快取失效：

- [WebhookService](mdc:src/webhook/webhook.service.ts) 處理鏈上事件通知
- 當地址活動事件到達時，相關地址的快取會被清除
- 使用簽名驗證確保 Webhook 請求的真實性

## 快取鍵策略

快取鍵格式為：`portfolio:{chainType}:{address}`，例如：
- `portfolio:eth:0x1234...` （以太坊地址）
- `portfolio:sol:ABC123...` （Solana 地址）

## 錯誤處理

- 快取錯誤不會導致應用程序失敗
- 快取服務捕獲並記錄所有可能的錯誤
- 提供優雅的降級機制

# 快取策略

本專案使用 cache-manager v6 結合 Keyv 架構實現可靠的快取系統，支援 Redis 和記憶體快取模式。

## 架構概述

- 核心架構基於 NestJS 的 `@nestjs/cache-manager`
- 使用 `@keyv/redis` 作為 Redis 介面
- 支援自動降級到記憶體快取（當 Redis 不可用時）
- 實現優化的模式刪除和快取失效策略

## 關鍵文件

- [src/core/cache/cache.module.ts](mdc:src/core/cache/cache.module.ts) - 快取模組配置
- [src/core/cache/cache.service.ts](mdc:src/core/cache/cache.service.ts) - 快取服務實現
- [src/core/cache/cache-key.service.ts](mdc:src/core/cache/cache-key.service.ts) - 快取鍵管理

## 重要考量

### Redis 客戶端獲取

在 cache-manager v6 + Keyv 架構中，Redis 客戶端的位置不固定，需要使用多路徑檢測：

```typescript
// 使用多路徑檢測 Redis 客戶端
const storeAny = store as any;
const redisClient =
  storeAny?.opts?.store?._redis ||
  storeAny?._store?._redis ||
  storeAny?.opts?.store?._client ||
  storeAny?._store?._client ||
  storeAny?.opts?.store?.client ||
  storeAny?._store?.client;
```

為避免訪問私有屬性的 TypeScript 錯誤，可使用 `any` 類型斷言並配合 try-catch 處理：

```typescript
try {
  // 嘗試獲取 Redis 客戶端
  const redisClient = /* 多路徑檢測代碼 */
  return redisClient;
} catch (e) {
  // 處理可能的錯誤
  return null;
}
```

### TTL 處理

注意 TTL 單位轉換：
- 在 `cache.service.ts` 中，API 接受秒為單位的 TTL
- 在設置快取時需轉換為毫秒：`await this.cacheManager.set(key, value, ttlSeconds * 1000);`
- 在配置 Memory 快取時也使用毫秒：`new Keyv({ ttl: 5 * 60 * 1000 })`

### 錯誤處理和重連

實現了完整的錯誤處理和自動重連機制：
- 監聽 Redis 錯誤事件
- 自動嘗試重連
- 連接狀態監控
- 降級到記憶體快取

### 模式刪除策略

使用 SCAN + UNLINK 非阻塞方式刪除符合模式的快取：
```typescript
// 批量刪除
const { cursor: next, keys } = await redis.scan(cursor, {
  MATCH: pattern,
  COUNT: 100,
});
if (keys.length) {
  await redis.unlink(keys); // 非阻塞刪除
}
```

### TypeScript 類型處理

在處理第三方庫自定義屬性時，使用類型斷言避免編譯錯誤：
```typescript
// 使用類型斷言處理 Keyv 內部結構
const redisClient = (store as any)?.opts?.store?._redis;
```

## 使用方法

1. **注入快取服務**：
   ```typescript
   constructor(private readonly cacheService: CacheService) {}
   ```

2. **快取操作**：
   ```typescript
   // 存儲資料（帶 TTL）
   await this.cacheService.set('your-key', data, 3600); // TTL 為 3600 秒

   // 讀取資料
   const data = await this.cacheService.get<YourType>('your-key');

   // 刪除快取
   await this.cacheService.delete('your-key');

   // 批次刪除（Redis 模式）
   await this.cacheService.deleteByPattern('prefix:*');
   ```

3. **檢查快取類型與連接狀態**：
   ```typescript
   const cacheType = this.cacheService.getCacheType(); // 'Redis' 或 'Memory'
   const isConnected = await this.cacheService.isRedisConnected(); // Redis 連接狀態
   ```

## 快取鍵策略

快取鍵格式為：`{prefix}:{chainType}:{chainId}:{address}`，例如：
- `portfolio:eth:1:0x1234...` （以太坊主網地址）
- `portfolio:sol:101:ABC123...` （Solana 地址）

[CacheKeyService](mdc:src/core/cache/cache-key.service.ts) 提供了創建與解析快取鍵的統一接口。

## 最佳實踐

1. 在進行快取操作前檢查 Redis 連接狀態
2. 對大量數據的快取使用適當的 TTL
3. 使用模式刪除批量無效化相關快取
4. 使用 `setTimeout` 搭配 `void` 操作符處理異步函數的返回值
5. 避免在事件處理器中直接使用 async 函數
6. 在關鍵更新後主動使相關快取失效
7. 使用多路徑檢測和 try-catch 處理提高 Redis 客戶端獲取的可靠性

## 快取過期策略

不同類型的數據適用不同的快取過期時間：

| 數據類型 | 建議過期時間 | 說明 |
|---------|------------|------|
| 餘額數據 | 1-5 分鐘   | 餘額可能頻繁變化 |
| 交易歷史 | 30 分鐘    | 歷史交易不會變更，但新交易會產生 |
| 代幣價格 | 1-10 分鐘  | 根據市場波動性調整 |
| NFT 元數據 | 1 小時    | 元數據較少變更 |

## Webhook 驅動的快取失效

系統使用 Webhook 事件通知來主動使快取失效：

- [WebhookService](mdc:src/webhook/webhook.service.ts) 處理鏈上事件通知
- 當地址活動事件到達時，相關地址的快取會被清除
- 使用簽名驗證確保 Webhook 請求的真實性

```typescript
// 使快取失效示例
async function handleTransferEvent(event: TransferEvent): Promise<void> {
  // 主動使相關快取失效
  await this.cacheKeyService.invalidateChainAddressCache(
    event.chain,
    event.chainId,
    event.address
  );

  this.logger.log(`Invalidated cache for ${event.chain}:${event.chainId}:${event.address}`);
}
```

## 快取優化技巧

1. **分層快取**：熱門數據使用更快的記憶體快取
2. **背景刷新**：在快取即將過期前異步刷新
3. **條件快取**：對不同用戶、不同場景使用不同快取策略
4. **快取壓縮**：大量數據使用壓縮算法節省記憶體
