---
description: Blockchain Provider
globs:
alwaysApply: false
---
# 區塊鏈提供者指南

本文檔說明了系統中的區塊鏈提供者架構及如何使用和配置新的區塊鏈提供者。

## 架構概述

系統採用多層架構設計，將區塊鏈服務與區塊鏈提供者分離：

1. **服務層**：[ChainService](mdc:src/chains/interfaces/chain-service.interface.ts) 和 [BalanceQueryable](mdc:src/chains/interfaces/balance-queryable.interface.ts) 提供統一的業務介面
2. **工廠層**：[ChainServiceFactory](mdc:src/chains/services/chain-service.factory.ts) 負責管理鏈服務，[ProviderFactory](mdc:src/providers/provider.factory.ts) 負責管理提供者
3. **提供者層**：各區塊鏈的具體提供者實現 [BlockchainProviderInterface](mdc:src/providers/interfaces/blockchain-provider.interface.ts)
4. **服務發現**：使用 [ProviderDiscoveryService](mdc:src/providers/provider-discovery.service.ts) 自動發現和註冊提供者

## 區塊鏈服務與提供者關係

系統通過工廠模式和依賴注入實現了區塊鏈服務與提供者的解耦：

```
BalanceService ──────► ChainServiceFactory ──────► ChainService (實現 BalanceQueryable)
                                                     │
                                                     ▼
                                                ProviderFactory ──────► BlockchainProviderInterface
```

此設計遵循依賴反轉原則，使服務和提供者可以獨立開發和測試。

## 提供者服務發現與多鏈支援

系統使用裝飾器和服務發現機制自動註冊提供者：

1. 使用 `@Provider` 裝飾器標記區塊鏈提供者類
2. `ProviderDiscoveryService` 在應用啟動時自動發現這些提供者
3. `ProviderFactory` 將發現的提供者註冊並管理實例

```typescript
@Provider({
  blockchainType: [ChainName.ETHEREUM, ChainName.POLYGON, ChainName.BSC], // 支援多個EVM鏈
  providerType: ProviderType.ALCHEMY,
})
@Injectable()
export class EthereumAlchemyProvider extends AbstractEvmProviderService {
  // 實現...
}
```

## 提供者介面階層

系統實現了分層的提供者介面架構：

1. **基礎介面**：[BlockchainProviderInterface](mdc:src/providers/interfaces/blockchain-provider.interface.ts) - 所有區塊鏈提供者必須實現
2. **鏈特定介面**：
   - [EvmProviderInterface](mdc:src/providers/interfaces/evm-provider.interface.ts) - EVM相容鏈提供者介面
   - [SolanaProviderInterface](mdc:src/providers/interfaces/solana-provider.interface.ts) - Solana提供者介面
3. **向後相容性**：
   - `EthereumProviderInterface`現在是`EvmProviderInterface`的別名

核心方法包括：

```typescript
export interface BlockchainProviderInterface {
  getProviderName(): string;
  isSupported(): boolean;
  getBalances(address: string, networkType?: NetworkType, chainName?: ChainName): Promise<BalancesResponse>;
  getBaseUrl(networkType?: NetworkType, chainName?: ChainName): string;
  getApiKey(networkType?: NetworkType, chainName?: ChainName): string;
}
```

## 抽象提供者實現

系統提供了抽象基類以簡化提供者開發：

1. **AbstractProviderService**：所有提供者的基礎類
2. **AbstractEvmProviderService**：EVM鏈提供者的基礎類，包含共用EVM功能
3. **AbstractEthereumProviderService**：以太坊專用提供者（向後相容）

此階層允許代碼重用並確保一致的實現。

## 餘額查詢流程

當用戶請求獲取區塊鏈地址餘額時，系統遵循以下流程：

1. `BalanceService.getPortfolio()` 方法接收鏈名稱和地址
2. 使用 `ChainServiceFactory` 獲取對應的鏈服務
3. 驗證鏈服務是否實現了 `BalanceQueryable` 介面
4. 調用 `getBalances()` 方法，該方法內部使用 `ProviderFactory` 獲取適當的提供者
5. 提供者執行實際的區塊鏈查詢並返回統一格式的結果

## 添加新的區塊鏈提供者

要添加新的區塊鏈提供者，請遵循以下步驟：

1. **選擇適當的基類**：
   - 對於EVM相容鏈，繼承 `AbstractEvmProviderService`
   - 對於其他鏈類型，繼承 `AbstractProviderService`

2. **使用 @Provider 裝飾器標記並支援多鏈**：
   ```typescript
   @Provider({
     blockchainType: [ChainName.CHAIN_1, ChainName.CHAIN_2], // 支援多個鏈
     providerType: ProviderType.YOUR_PROVIDER,
   })
   @Injectable()
   export class YourEvmProvider extends AbstractEvmProviderService {
     // 實現...
   }
   ```

3. **設置支援的鏈**：
   ```typescript
   constructor() {
     super();
     this.initSupportedChains([ChainName.CHAIN_1, ChainName.CHAIN_2]);
   }
   ```

4. **在模組中註冊**：在 `ProvidersModule` 的 `providers` 數組中添加你的提供者類

5. **配置環境變數**：在 `.env` 文件中添加必要的 API 密鑰

## 使用提供者

可以通過 `ProviderFactory` 獲取提供者實例：

```typescript
// 注入 ProviderFactory
constructor(private readonly providerFactory: ProviderFactory) {}

// 獲取特定提供者
const evmProvider = this.providerFactory.getProvider(ChainName.ETHEREUM);

// 獲取特定提供者類型
const alchemyProvider = this.providerFactory.getProvider(
  ChainName.ETHEREUM,
  ProviderType.ALCHEMY
);

// 檢查提供者是否支援特定鏈
if (evmProvider.supportsChain(ChainName.POLYGON)) {
  // 使用同一提供者處理Polygon
  const balances = await evmProvider.getBalances(address, networkType, ChainName.POLYGON);
}
```

## 當前支援的提供者

1. **EVM鏈提供者**：
   - [`EthereumAlchemyProvider`](mdc:src/providers/implementations/ethereum/ethereum-alchemy.provider.ts) - 使用Alchemy API的EVM提供者，支援多個EVM鏈
   - [`EthereumQuickNodeProvider`](mdc:src/providers/implementations/ethereum/ethereum-quicknode.provider.ts) - 使用QuickNode API的EVM提供者

2. **Solana提供者**：
   - [`SolanaAlchemyProvider`](mdc:src/providers/implementations/solana/solana-alchemy.provider.ts) - 使用Alchemy API的Solana提供者

## 多鏈配置管理

系統使用鏈信息映射來管理不同的EVM鏈配置：

```typescript
// 在constants.ts中
export const EVM_CHAIN_INFO_MAP: Record<ChainName, ChainInfo> = {
  [ChainName.ETHEREUM]: {
    id: 1,
    display: 'Ethereum',
    symbol: 'ETH',
    decimals: 18,
    isMainnet: true,
  },
  [ChainName.POLYGON]: {
    id: 137,
    display: 'Polygon',
    symbol: 'MATIC',
    decimals: 18,
    isMainnet: true,
  },
  // 其他EVM鏈...
};
```

提供者可以使用這些映射來獲取特定鏈的配置：

```typescript
getChainConfig(chainName: ChainName): ChainConfig {
  const chainInfo = EVM_CHAIN_INFO_MAP[chainName];
  if (!chainInfo) {
    throw new Error(`Chain config not found for ${chainName}`);
  }
  return {
    chainId: chainInfo.id,
    name: chainInfo.display,
    nativeSymbol: chainInfo.symbol,
    // ...
  };
}
```

## 鏈特定操作

對於支援多鏈的提供者，所有操作都應接受`chainName`參數：

```typescript
async getGasPrice(networkType?: NetworkType, chainName?: ChainName): Promise<string> {
  // 選擇適當的鏈客戶端
  const client = this.getChainClient(chainName || ChainName.ETHEREUM, networkType);
  // 執行操作
  return client.getGasPrice();
}
```

## 錯誤處理

區塊鏈提供者遵循統一的錯誤處理機制：

- 使用 [ErrorCode](mdc:src/common/constants/error-codes.ts) 枚舉定義錯誤類型
- 抛出特定的異常類，如 `ProviderException`
- 在響應中提供詳細的錯誤信息

示例：

```typescript
if (!this.supportsChain(chainName)) {
  throw new ProviderException(
    ErrorCode.UNSUPPORTED_CHAIN,
    `Provider ${this.getProviderName()} does not support chain ${chainName}`
  );
}
```

## 提供者實現檢查清單

確保您的提供者實現了以下方法：

- `getProviderName()`: 獲取提供者名稱
- `getBaseUrl(networkType?, chainName?)`: 獲取API基本URL
- `getChainConfig(chainName?)`: 獲取鏈配置
- `getApiKey(networkType?, chainName?)`: 獲取API密鑰
- `getBalances(address, networkType?, chainName?)`: 獲取餘額
- `isSupported()`: 檢查提供者是否被支持
- `supportsChain(chainName)`: 檢查提供者是否支援特定鏈

## 測試網絡支援

系統支援主網和測試網切換，通過 `NetworkType` 枚舉：

```typescript
export enum NetworkType {
  MAINNET = 'mainnet',
  TESTNET = 'testnet',
}
```

提供者需要根據 `networkType` 和 `chainName` 參數返回相應網絡的數據。

## 擴展指南

### 1. 添加新的區塊鏈類型

在 [constants.ts](mdc:src/chains/constants.ts) 中添加新類型：

```typescript
export enum ChainName {
  ETHEREUM = 'ethereum',
  POLYGON = 'polygon',
  BSC = 'bsc',
  YOUR_BLOCKCHAIN = 'your_blockchain',
}
```

### 2. 添加新的提供者類型

在 [blockchain-types.ts](mdc:src/providers/constants/blockchain-types.ts) 中添加新的提供者類型：

```typescript
export enum ProviderType {
  ALCHEMY = 'alchemy',
  QUICKNODE = 'quicknode',
  YOUR_PROVIDER = 'your_provider',
}
```

### 3. 實現新的提供者類

創建繼承自適當抽象基類的提供者實現：

```typescript
@Provider({
  blockchainType: [ChainName.CHAIN_1, ChainName.CHAIN_2],
  providerType: ProviderType.YOUR_PROVIDER,
})
@Injectable()
export class YourEvmProvider extends AbstractEvmProviderService {
  constructor() {
    super();
    this.initSupportedChains([ChainName.CHAIN_1, ChainName.CHAIN_2]);
  }

  // 實現特定方法...
}
```

### 4. 在對應的鏈服務中使用提供者

更新或創建新的鏈服務，實現 `BalanceQueryable` 介面：

```typescript
@Injectable()
@Chain(ChainName.YOUR_CHAIN)
export class YourChainService extends AbstractChainService implements BalanceQueryable {
  constructor(private readonly providerFactory: ProviderFactory) {
    super();
  }

  // ... existing code ...
}
```

## 故障排除

- 如果提供者未被正確註冊，檢查 imports 和 exports
- 如果 API 調用失敗，檢查 API 密鑰和 URL
- 如果返回的數據格式不正確，檢查轉換邏輯
- 使用日誌記錄診斷問題，例如 `this.logger.debug()`
- 如果提供者無法識別鏈，檢查 `supportsChain` 方法實現

## 向後相容性

系統設計保持向後相容性，舊的以太坊專用代碼仍然有效：

```typescript
// 舊的方法（僅以太坊）
getGasPrice(networkType?: NetworkType): Promise<string>;

// 新的方法（支援多鏈）
getGasPrice(networkType?: NetworkType, chainName?: ChainName): Promise<string>;
```

當不指定 `chainName` 時，系統默認使用 `ChainName.ETHEREUM`。

# 區塊鏈提供者 (Blockchain Provider)

本專案使用多種區塊鏈提供者來與不同的區塊鏈網絡互動。區塊鏈提供者實現統一的介面，但針對每個區塊鏈有特定的實現細節。

## 主要提供者

- **以太坊提供者**：使用 [ethers](mdc:https:/docs.ethers.org) 庫與以太坊區塊鏈交互
- **Solana 提供者**：使用 [@solana/web3.js](mdc:https:/solana-labs.github.io/solana-web3.js) 與 Solana 區塊鏈交互

## 地址驗證

每個區塊鏈有特定的地址格式和驗證邏輯：

### 以太坊地址驗證

以太坊服務 [src/chains/services/ethereum/ethereum.service.ts](mdc:src/chains/services/ethereum/ethereum.service.ts) 使用 `isAddress` 函數進行嚴謹的地址驗證：

```typescript
import { isAddress } from 'ethers';

// 驗證以太坊地址
const isValid = isAddress('0x742d35Cc6634C0532925a3b844Bc454e4438f44e');
```

### Solana 地址驗證

Solana 服務 [src/chains/services/solana/solana.service.ts](mdc:src/chains/services/solana/solana.service.ts) 使用 `PublicKey` 類進行地址驗證：

```typescript
import { PublicKey } from '@solana/web3.js';

// 驗證 Solana 地址
try {
  new PublicKey('9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin');
  console.log('Address is valid');
} catch (error) {
  console.error('Invalid address');
}
```

## 擴展新的區塊鏈提供者

要添加新的區塊鏈提供者，需要：

1. 在 `src/providers/blockchain/` 目錄中創建新的提供者類
2. 在 `StandardChainType` 枚舉中添加新的鏈類型
3. 在 `BlockchainProviderFactory` 中添加新的提供者處理邏輯
4. 創建相應的服務類並繼承 `AbstractChainService`
5. 使用 `@Chain()` 裝飾器標記新服務

# 區塊鏈提供者服務模組

本項目實現了一個模組化的區塊鏈服務架構，通過統一介面支援多種區塊鏈。

## 架構概述

系統使用混合架構設計，結合了工廠模式、裝飾器自動註冊和模組化原則：

1. **統一介面**：所有鏈服務實現 [ChainService](mdc:src/chains/interfaces/chain-service.interface.ts) 介面
2. **抽象基類**：[AbstractChainService](mdc:src/chains/services/abstract-chain.service.ts) 提供通用實現
3. **工廠模式**：[ChainServiceFactory](mdc:src/chains/services/chain-service.factory.ts) 管理服務實例
4. **裝飾器註冊**：使用 [@Chain](mdc:src/chains/decorators/chain.decorator.ts) 裝飾器自動發現和註冊服務
5. **模組化**：每條鏈擁有獨立模組和服務實現

## 支援的區塊鏈

目前支援的區塊鏈包括：

- **以太坊** (ETH)：完整支援地址驗證、交易查詢
- **Solana** (SOL)：完整支援地址驗證、交易查詢

## 使用方法

1. **注入工廠服務**：
   ```typescript
   constructor(private readonly chainServiceFactory: ChainServiceFactory) {}
   ```

2. **獲取特定鏈服務**：
   ```typescript
   // 使用鏈名稱
   const ethService = this.chainServiceFactory.getChainService(ChainName.ETHEREUM);

   // 也可使用代幣符號（不區分大小寫）
   const solService = this.chainServiceFactory.getChainService('sol');
   ```

3. **使用服務方法**：
   ```typescript
   const isValid = ethService.isValidAddress('0x...');
   const txHashes = await solService.getAddressTransactionHashes('sol_address');
   ```

## 擴展新區塊鏈

添加新的區塊鏈支援需要：

1. 更新 [constants/index.ts](mdc:src/chains/constants/index.ts) 中的 `ChainName` 枚舉
2. 創建繼承 `AbstractChainService` 的服務類並使用 `@Chain()` 裝飾器
3. 在主模組中導入新的鏈特定模組

詳細實作請參考 [README.md](mdc:src/chains/README.md) 中的擴展指南。
