---
description: Blockchain Provider
globs:
alwaysApply: false
---
# 區塊鏈提供者指南

本文檔說明了系統中的區塊鏈提供者架構及如何使用和配置新的區塊鏈提供者。

## 架構概述

系統採用多層架構設計，將區塊鏈服務與區塊鏈提供者分離：

1. **服務層**：[ChainService](mdc:src/chains/interfaces/chain-service.interface.ts) 和 [BalanceQueryable](mdc:src/chains/interfaces/balance-queryable.interface.ts) 提供統一的業務介面
2. **工廠層**：[ChainServiceFactory](mdc:src/chains/services/chain-service.factory.ts) 負責管理鏈服務，[ProviderFactory](mdc:src/providers/provider.factory.ts) 負責管理提供者
3. **提供者層**：各區塊鏈的具體提供者實現 [BlockchainProviderInterface](mdc:src/providers/interfaces/blockchain-provider.interface.ts)
4. **服務發現**：使用 [ProviderDiscoveryService](mdc:src/providers/provider-discovery.service.ts) 自動發現和註冊提供者

## 區塊鏈服務與提供者關係

系統通過工廠模式和依賴注入實現了區塊鏈服務與提供者的解耦：

```
BalanceService ──────► ChainServiceFactory ──────► ChainService (實現 BalanceQueryable)
                                                     │
                                                     ▼
                                                ProviderFactory ──────► BlockchainProviderInterface
```

此設計遵循依賴反轉原則，使服務和提供者可以獨立開發和測試。

## 提供者服務發現

系統使用裝飾器和服務發現機制自動註冊提供者：

1. 使用 `@Provider` 裝飾器標記區塊鏈提供者類
2. `ProviderDiscoveryService` 在應用啟動時自動發現這些提供者
3. `ProviderFactory` 將發現的提供者註冊並管理實例

```typescript
@Provider({
  blockchainType: BlockchainType.ETHEREUM,
  providerType: ProviderType.ALCHEMY,
})
@Injectable()
export class EthereumAlchemyProvider extends AbstractEthereumProviderService {
  // 實現...
}
```

## 提供者介面

所有區塊鏈提供者必須實現 `BlockchainProviderInterface`，為特定區塊鏈提供專用介面：

- [EthereumProviderInterface](mdc:src/providers/interfaces/ethereum-provider.interface.ts) - 以太坊提供者介面
- [SolanaProviderInterface](mdc:src/providers/interfaces/solana-provider.interface.ts) - Solana 提供者介面

核心方法包括：

```typescript
export interface BlockchainProviderInterface {
  getProviderName(): string;
  isSupported(): boolean;
  getBalances(address: string, networkType?: NetworkType): Promise<BalancesResponse>;
  getBaseUrl(networkType?: NetworkType): string;
  getApiKey(networkType?: NetworkType): string;
}
```

## 餘額查詢流程

當用戶請求獲取區塊鏈地址餘額時，系統遵循以下流程：

1. `BalanceService.getPortfolio()` 方法接收鏈名稱和地址
2. 使用 `ChainServiceFactory` 獲取對應的鏈服務
3. 驗證鏈服務是否實現了 `BalanceQueryable` 介面
4. 調用 `getBalances()` 方法，該方法內部使用 `ProviderFactory` 獲取適當的提供者
5. 提供者執行實際的區塊鏈查詢並返回統一格式的結果

## 添加新的區塊鏈提供者

要添加新的區塊鏈提供者，請遵循以下步驟：

1. **創建介面實現**：實現對應區塊鏈的提供者介面

2. **使用 @Provider 裝飾器標記**：
   ```typescript
   @Provider({
     blockchainType: BlockchainType.YOUR_BLOCKCHAIN,
     providerType: ProviderType.YOUR_PROVIDER,
   })
   @Injectable()
   export class YourBlockchainProvider implements BlockchainProviderInterface {
     // 實現...
   }
   ```

3. **在模組中註冊**：在 `ProvidersModule` 的 `providers` 數組中添加你的提供者類

4. **配置環境變數**：在 `.env` 文件中添加必要的 API 密鑰

## 使用提供者

可以通過 `ProviderFactory` 獲取提供者實例：

```typescript
// 注入 ProviderFactory
constructor(private readonly providerFactory: ProviderFactory) {}

// 獲取特定提供者
const ethProvider = this.providerFactory.getProvider(BlockchainType.ETHEREUM);
// 或使用便捷方法
const ethProvider = this.providerFactory.getEthereumProvider();

// 獲取特定提供者類型
const alchemyProvider = this.providerFactory.getProvider(
  BlockchainType.ETHEREUM,
  ProviderType.ALCHEMY
);
```

## 當前支援的提供者

1. **以太坊提供者**：
   - [`EthereumAlchemyProvider`](mdc:src/providers/implementations/ethereum/ethereum-alchemy.provider.ts) - 使用 Alchemy API 的以太坊提供者

2. **Solana提供者**：
   - [`SolanaAlchemyProvider`](mdc:src/providers/implementations/solana/solana-alchemy.provider.ts) - 使用 Alchemy API 的 Solana 提供者

## 錯誤處理

區塊鏈提供者遵循統一的錯誤處理機制：

- 使用 [ErrorCode](mdc:src/common/constants/error-codes.ts) 枚舉定義錯誤類型
- 抛出特定的異常類，如 `ProviderException`
- 在響應中提供詳細的錯誤信息

示例：

```typescript
if (!this.apiKey) {
  throw new ProviderException(
    ErrorCode.PROVIDER_AUTH_FAILED,
    `API key not provided for ${this.getProviderName()}`
  );
}
```

## 提供者實現檢查清單

確保您的提供者實現了以下方法：

- `getProviderName()`: 獲取提供者名稱
- `getBaseUrl(networkType?)`: 獲取 API 基本 URL
- `getChainConfig()`: 獲取鏈配置
- `getApiKey(networkType?)`: 獲取 API 密鑰
- `getBalances(address, networkType?)`: 獲取餘額
- `isSupported()`: 檢查提供者是否被支持

## 測試網絡支援

系統支援主網和測試網切換，通過 `NetworkType` 枚舉：

```typescript
export enum NetworkType {
  MAINNET = 'mainnet',
  TESTNET = 'testnet',
}
```

提供者需要根據 `networkType` 參數返回相應網絡的數據。

## 擴展指南

### 1. 添加新的區塊鏈類型

在 [blockchain-types.ts](mdc:src/providers/constants/blockchain-types.ts) 中添加新類型：

```typescript
export enum BlockchainType {
  ETHEREUM = 'ethereum',
  SOLANA = 'solana',
  YOUR_BLOCKCHAIN = 'your_blockchain',
}
```

### 2. 添加新的提供者類型

在 [blockchain-types.ts](mdc:src/providers/constants/blockchain-types.ts) 中添加新的提供者類型：

```typescript
export enum ProviderType {
  ALCHEMY = 'alchemy',
  INFURA = 'infura',
  YOUR_PROVIDER = 'your_provider',
}
```

### 3. 實現新的提供者類

創建繼承自抽象基類的提供者實現：

```typescript
@Provider({
  blockchainType: BlockchainType.YOUR_BLOCKCHAIN,
  providerType: ProviderType.YOUR_PROVIDER,
})
@Injectable()
export class YourBlockchainProvider extends AbstractProviderService {
  // 實現特定方法...
}
```

### 4. 在對應的鏈服務中使用提供者

更新或創建新的鏈服務，實現 `BalanceQueryable` 介面：

```typescript
@Injectable()
@Chain(ChainName.YOUR_CHAIN)
export class YourChainService extends AbstractChainService implements BalanceQueryable {
  constructor(private readonly providerFactory: ProviderFactory) {
    super();
  }

  // ... existing code ...
}
```

## 故障排除

- 如果提供者未被正確註冊，檢查 imports 和 exports
- 如果 API 調用失敗，檢查 API 密鑰和 URL
- 如果返回的數據格式不正確，檢查轉換邏輯
- 使用日誌記錄診斷問題，例如 `this.logger.debug()`

# 區塊鏈提供者 (Blockchain Provider)

本專案使用多種區塊鏈提供者來與不同的區塊鏈網絡互動。區塊鏈提供者實現統一的介面，但針對每個區塊鏈有特定的實現細節。

## 主要提供者

- **以太坊提供者**：使用 [ethers](mdc:https:/docs.ethers.org) 庫與以太坊區塊鏈交互
- **Solana 提供者**：使用 [@solana/web3.js](mdc:https:/solana-labs.github.io/solana-web3.js) 與 Solana 區塊鏈交互

## 地址驗證

每個區塊鏈有特定的地址格式和驗證邏輯：

### 以太坊地址驗證

以太坊服務 [src/chains/services/ethereum/ethereum.service.ts](mdc:src/chains/services/ethereum/ethereum.service.ts) 使用 `isAddress` 函數進行嚴謹的地址驗證：

```typescript
import { isAddress } from 'ethers';

// 驗證以太坊地址
const isValid = isAddress('0x742d35Cc6634C0532925a3b844Bc454e4438f44e');
```

### Solana 地址驗證

Solana 服務 [src/chains/services/solana/solana.service.ts](mdc:src/chains/services/solana/solana.service.ts) 使用 `PublicKey` 類進行地址驗證：

```typescript
import { PublicKey } from '@solana/web3.js';

// 驗證 Solana 地址
try {
  new PublicKey('9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin');
  console.log('Address is valid');
} catch (error) {
  console.error('Invalid address');
}
```

## 擴展新的區塊鏈提供者

要添加新的區塊鏈提供者，需要：

1. 在 `src/providers/blockchain/` 目錄中創建新的提供者類
2. 在 `StandardChainType` 枚舉中添加新的鏈類型
3. 在 `BlockchainProviderFactory` 中添加新的提供者處理邏輯
4. 創建相應的服務類並繼承 `AbstractChainService`
5. 使用 `@Chain()` 裝飾器標記新服務

# 區塊鏈提供者服務模組

本項目實現了一個模組化的區塊鏈服務架構，通過統一介面支援多種區塊鏈。

## 架構概述

系統使用混合架構設計，結合了工廠模式、裝飾器自動註冊和模組化原則：

1. **統一介面**：所有鏈服務實現 [ChainService](mdc:src/chains/interfaces/chain-service.interface.ts) 介面
2. **抽象基類**：[AbstractChainService](mdc:src/chains/services/abstract-chain.service.ts) 提供通用實現
3. **工廠模式**：[ChainServiceFactory](mdc:src/chains/services/chain-service.factory.ts) 管理服務實例
4. **裝飾器註冊**：使用 [@Chain](mdc:src/chains/decorators/chain.decorator.ts) 裝飾器自動發現和註冊服務
5. **模組化**：每條鏈擁有獨立模組和服務實現

## 支援的區塊鏈

目前支援的區塊鏈包括：

- **以太坊** (ETH)：完整支援地址驗證、交易查詢
- **Solana** (SOL)：完整支援地址驗證、交易查詢

## 使用方法

1. **注入工廠服務**：
   ```typescript
   constructor(private readonly chainServiceFactory: ChainServiceFactory) {}
   ```

2. **獲取特定鏈服務**：
   ```typescript
   // 使用鏈名稱
   const ethService = this.chainServiceFactory.getChainService(ChainName.ETHEREUM);

   // 也可使用代幣符號（不區分大小寫）
   const solService = this.chainServiceFactory.getChainService('sol');
   ```

3. **使用服務方法**：
   ```typescript
   const isValid = ethService.isValidAddress('0x...');
   const txHashes = await solService.getAddressTransactionHashes('sol_address');
   ```

## 擴展新區塊鏈

添加新的區塊鏈支援需要：

1. 更新 [constants/index.ts](mdc:src/chains/constants/index.ts) 中的 `ChainName` 枚舉
2. 創建繼承 `AbstractChainService` 的服務類並使用 `@Chain()` 裝飾器
3. 在主模組中導入新的鏈特定模組

詳細實作請參考 [README.md](mdc:src/chains/README.md) 中的擴展指南。
